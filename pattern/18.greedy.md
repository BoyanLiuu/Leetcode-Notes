# 18.Greedy

## Summary:

Greedy is an algorithmic paradigm where the solution is built piece by piece. The next piece that offers the most obvious and immediate benefit is chosen. The greedy approach always makes the choice that maximizes the profit and minimizes the cost at any given point. It means that a locally-optimal choice is made in the hope that it leads to a globally optimal solution

### Advantage:

* **Easy to devise**: It is easier to come up with a greedy approach for a single problem rather than computing solutions via other ways like binary search, dynamic programming
* **Compute the running time complexity:** Analyzing the run time for greedy algorithms is generally simpler than other techniques like traversals of trees, graph algorithms, or divide and conquer.

### Disadvantage:

* **Un-optimized solution**: One of the major disadvantages of the greedy approach is that initially, you might take a smaller step that leads to one big step that costs the maximum. Therefore, the final solution can never be optimized
* **Proof of correctness**: For greedy algorithms, it is harder to understand the correctness issues of a solution. Even with the correct algorithm, it is hard to prove why it is correct? While proving the correctness of a greedy algorithm, it requires a good deal of effort and patience. Moreover, the methods like proof of correctness via contradiction are used for this purpose

### 





## Easy:

### [322. Coin Change](https://leetcode.com/problems/coin-change/)

### This one need to use dp 

![](../.gitbook/assets/image%20%2853%29.png)

```text
//This only works for 1,5,10,25 cents case, does not apply to all the generic cases
public int coinChange(int[] coins, int amount) {
    Arrays.sort(coins);
    int index = coins.length -1;
    int count =0;
    for (int i = index; i >=0&& amount > 0; i--) // traverse through all available coins
    {
       while (amount >= coins[i]) // keep checking if the amount is greater than the max coin
       {
        amount -= coins[i]; // subtract the maximum coin selected from the total amount in every iteration
       count++;
       }

    }

        return   count ;
    }
```

### Find the Largest Number:

Given sum of digits and number of digits , give the largest number available

```text
 public static void findLargestNumber(int number_of_digits, int sum_of_digits) {
  int[] result = new int[number_of_digits];
  // If sum of digits is 0, then a number is possible only if number of digits is 1. 
  if (sum_of_digits == 0) {
   if (number_of_digits == 1) {
    System.out.print(0);
   } else {
    System.out.print("Noned");
   }
   return;
  }
  // sumOfDigits is greater than the maximum possible sum. 
  if (sum_of_digits > 9 * number_of_digits) {
   System.out.print("None");
   return;
  }
  // Fill from most significant digit to least significant digit! 
  for (int i = 0; i < number_of_digits; i++) {
   // Place 9 to make the number largest 
   if (sum_of_digits >= 9) {
    result[i] = 9;
    sum_of_digits -= 9;
   }
   // If remaining sum becomes less than 9, then fill the remaining sum 
   else {
    result[i] = sum_of_digits;
    sum_of_digits = 0;
   }
  }
  for (int i = 0; i < number_of_digits; i++) {
   System.out.print(result[i]);
  }
 }
```

* Fill in the digits one by one, from the leftmost to the rightmost digit

## Medium:

### [1167. Minimum Cost to Connect Stick](https://leetcode.com/problems/minimum-cost-to-connect-sticks/)

```text
    public int connectSticks(int[] sticks) {
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        for (int s : sticks) {
            pq.offer(s);
        }
        int sum = 0;
        while (pq.size() > 1) {
            int two = pq.poll() + pq.poll();
            sum += two;
            pq.offer(two);
        }
        return sum;
    }
```

### Find Egyptian  Fraction:

Every positive fraction can be represented as sum of unique unit fractions. A fraction is unit fraction if numerator is 1 and denominator is a positive integer, for example 1/3 is a unit fraction. Such a representation is called Egyptian Fraction as it was used by ancient Egyptians. 

Following are few examples: 

`Egyptian Fraction Representation of 2/3 is 1/2 + 1/6`

`Egyptian Fraction Representation of 6/14 is 1/3 + 1/11 + 1/231`

`Egyptian Fraction Representation of 12/13 is 1/2 + 1/3 + 1/12 + 1/156`

**Solution:**

* **Time Complexity:**  O\(LOGN\)
* We can generate Egyptian fractions using the greedy algorithm. For a given number of the form n/d, where d &gt; n, first find the greatest possible unit fraction, and then perform recursion for the remaining part.
* For example, consider 6/14. We first find the ceiling of \lceil 14/6 \rceil⌈14/6⌉, i.e., 33, so the first unit fraction becomes 1/3. Now subtract 1/3 out of 6/14 and recur for \(\(6/14 – $1/3\), $ i.e.,4/42.
*  _the recursive calls keep on reducing the numerator till it reaches 1._ 

```text
 public static void printEgyptianFraction(int numerator, int denominator) 
    {
      //if either numerator or denominator is zero
      if (denominator == 0 || numerator == 0){
        return;
      }
      //numerator divides denominator -> fraction in 1/n form
      if (denominator % numerator == 0) {
        System.out.print("1/" + denominator / numerator);
        return;
      }
      //denominator can divide numerator -> number not a fraction 
      if (numerator % denominator == 0) {
        System.out.println(numerator / denominator);
        return;
      }
      //if numerator greater than denominator 
      if (numerator > denominator) {
        System.out.println(numerator / denominator + " , ");
        printEgyptianFraction(numerator % denominator, denominator);
        return;
      }
      //denominator  greater than numerator here
      int n = denominator / numerator + 1;
      System.out.print("1/" + n + " , ");
      //call function recursively for remaining part  
      printEgyptianFraction(numerator * n - denominator, denominator * n);
}
```



### [253. Meeting Rooms II](https://leetcode.com/problems/meeting-rooms-ii/)

Implement a function that returns the minimum number of platforms that are required for the trains so that none of them wait.

![](../.gitbook/assets/image%20%2854%29.png)

![](../.gitbook/assets/image%20%2852%29.png)

* Time Complexity: O\(nlog n\)
* Create a min heap that sort by ending time
* Sort array in ascending order for starting time
* Then  calculate the current heap size to determine maximum room we need.

### Help the Police Officers Catch the Thieves!

The input is an array in which each element contains either a police officer \(P\) or a thief \(T\).

`Each police officer can catch only one thief, and a police officer cannot catch a thief who is more than k units away from him.`



![](../.gitbook/assets/image%20%2851%29.png)



* Brutal Force: check all the possible combinations of police and thief, and then return their maximum size set.
* Greedy Approach: ignoring the police officers and focusing on assigning police to thieves.
* We get the lowest index of policeman pp and thief t. We take the absolute value \( \|p-t\|\) and make an allotment if the difference of the indexes is less than k . Next, we increment to the next p and t. If the difference is not less than k, increment the minimum of p and t to the next pp or t found.

```text
public static int policeThief(char[] arr, int k) {
  int result = 0;
  ArrayList < Integer > thieves = new ArrayList < Integer > ();
  ArrayList < Integer > police = new ArrayList < Integer > ();
  int n = arr.length;
  //store indices in the respective vector
  for (int i = 0; i < n; i++) {
   if (arr[i] == 'P') {
    police.add(i);
   } 
   else if (arr[i] == 'T') {
    thieves.add(i);
   }
  }
  int trackThieves = 0, trackPolice = 0;
  while (trackThieves < thieves.size() && trackPolice < police.size()) {
   //thieves can be caught
   if (Math.abs(thieves.get(trackThieves) - police.get(trackPolice)) <= k) {
    result++;
    trackThieves++;
    trackPolice++;
   }
   //increment the minimum index 
   else if (thieves.get(trackThieves) < police.get(trackPolice)) {
    trackThieves++;
   } 
   else {
    trackPolice++;
   }
  }


  return result;
 }
```

### Minimum Waiting  Time:

![](../.gitbook/assets/image%20%2860%29.png)

We can only dealing positive number. The minimum array is one. We can execute query any order we want, and the total waiting time should be the minimum

```text
public int minimumWaitingTime(int[] queries) {
	 Arrays.sort(queries);
		int totalWaitingTime = 0;
		for(int idx = 0; idx < queries.length; idx++){
				int duration =  queries[idx];
				int queriesLeft =  queries.length -(idx +1);
				totalWaitingTime += duration * queriesLeft;
		}
		
		return totalWaitingTime ;
  }
```

### Class Photos:

![](../.gitbook/assets/image%20%2863%29.png)

```text
  public boolean classPhotos(
      ArrayList<Integer> redShirtHeights, ArrayList<Integer> blueShirtHeights) {
    	Collections.sort(redShirtHeights,Collections.reverseOrder());
			Collections.sort(blueShirtHeights,Collections.reverseOrder());
			boolean  flag = redShirtHeights.get(0) < blueShirtHeights.get(0) ? true : false;
		
		 for(int idx = 0; idx < redShirtHeights.size(); idx++){
			 int redShirtHeight = redShirtHeights.get(idx);
			 int blueShirtHeight = blueShirtHeights.get(idx);
			 
			 if(flag){
				 if(blueShirtHeight <= redShirtHeight)
					 return false;
			 }else{
				 	if(redShirtHeight <= blueShirtHeight)
					 return false;
			 }
			 
		 }
    return true;
  }
}
```

## 

## Hard:

### Fractional Knapsack:

You are given the capacity of a knapsack WW and a list of ​”​​n​”​​ items that each have a certain value. Fractions of each item can be placed in the knapsack. Your goal is to implement a function for getting the maximum possible total value of VV in the knapsack.

![](../.gitbook/assets/image%20%2861%29.png)

* Time complexity: the major time is sorting algorithm O\(NlogN\)
* Use value / weight to and keep adding maximum ration item until no more weight can be added to the bag.

```text
class FractionalKnapsack {
 private static double getMaxValue(double[] w, double[] v, double c) {
  int totalItems = v.length;
  ItemValue[] iVal = new ItemValue[totalItems];

  for (int i = 0; i < totalItems; i++) {
   iVal[i] = new ItemValue(w[i], v[i], i);
  }

  Arrays.sort(iVal, new Comparator < ItemValue > () //sorting items by value;
   {
    public int compare(ItemValue sampleObj1, ItemValue sampleObj2) {
     return sampleObj2.cost.compareTo(sampleObj1.cost);
    }
   });
  double totalValue = 0;
  for (ItemValue i: iVal) // iterator to traverse items list
  {
   double currWeight = (double) i.w;
   double currValue = (double) i.v;

   if (c - currWeight >= 0) // this item can be picked as whole 
   {
    c = c - currWeight;
    totalValue += currValue;

    // uncomment the following line to see the step by step working of this function
    // System.out.println("c, v, t = " + c + ", " + currValue + ", " + totalValue);
   } else // item can't be picked as whole
   {
    double fraction = ((double) c / (double) currWeight); // only a fraction of it can be obtained!
    totalValue += (currValue * fraction);
    c = (double)(c - (currWeight * fraction));

    // uncomment the following line to see the step by step working of this function
    // System.out.println("c, v, t = " + c + ", " + currValue + ", " + totalValue + "\n");
    break;
   }
  }
  return totalValue;
 }

 static class ItemValue // item value class 
 {
  Double cost;
  double w, v, i;

  public ItemValue(double weight, double value, int index) // constructor
  {
   w = weight;
   v = value;
   i = index;
   cost = new Double(v / w);
  }
 }
```

### Color the Graph:

Implement a function that finds a way of coloring a graph so that no two adjacent vertices are colored using the same color. Try using the minimum number of colors possible. The input is an undirected graph with no colors assigned.

![](../.gitbook/assets/image%20%2862%29.png)

![](../.gitbook/assets/image%20%2864%29.png)

#### Explanation:

The solution is simple: assign the first available color and make that color unavailable for the adjacent vertices.As seen above, start by coloring the first vertex with the first color. Then for the remaining vertices, color the current vertex with the lowest numbered color that has not been used on any previously colored vertices that are adjacent to it. If all previously used colors appear on vertices adjacent to it, assign a new color to it.

```text
 public static void greedyColoring(Graph g) {
  int numofVertices = g.getVertices();
  int[] result = new int[numofVertices];

  //Initialize vertices as unassigned 
  Arrays.fill(result, -1);

  //Assign the first color to first vertex 
  result[0] = 0;

  boolean[] available = new boolean[numofVertices];
  // Assign colors to remaining V-1 vertices 
  Arrays.fill(available, true);
  LinkedList < Integer > Llist[];
  //this return adjacent list of g
  Llist = g.getAdj();
  for (int i = 1; i < numofVertices; i++) {
   
    Iterator < Integer > var = Llist[i].iterator();
    while (var.hasNext()) {
    
     int temp = var.next();
    // Find the first available color 
    if (result[temp] != -1) {
     available[result[temp]] = false;
    }
   }
   int j;
   for (j = 0; j < numofVertices; j++) {
    if (available[j]) {
     break;
    }
   }

   result[i] = j; // Assign the found color 
   //reset the values
   Arrays.fill(available, true);
  }
  for (int i = 0; i < numofVertices; i++) {
   System.out.println("Vertex: " + i + " , " + "Color: " + result[i]);
  }
 }
```

### Tandem Bicycle:

![](../.gitbook/assets/image%20%2870%29.png)

![](../.gitbook/assets/image%20%2867%29.png)

```text
  public int tandemBicycle(int[] redShirtSpeeds, int[] blueShirtSpeeds, boolean fastest) {
		Arrays.sort(redShirtSpeeds);
		Arrays.sort(blueShirtSpeeds);
		for(int i: redShirtSpeeds){
			System.out.println(i);
		}
		if(!fastest) {
			reverseArrayInPlace(redShirtSpeeds);
		}
		int totalSpeed = 0;
		for(int idx =0; idx < redShirtSpeeds.length; idx++){
			int rider1 = redShirtSpeeds[idx];
			int rider2 = blueShirtSpeeds[blueShirtSpeeds.length - idx -1];
			totalSpeed += Math.max(rider1,rider2);
			
		}

    return totalSpeed ;
  }
	public void reverseArrayInPlace(int[] array){
		int start = 0;
		int end = array.length - 1;
		while(start < end){
			int temp = array[start];
			array[start] = array[end];
			array[end] = temp;
			start +=1;
			end -= 1;
		}	
	}
```

### Task Assignment:

![](../.gitbook/assets/image%20%2866%29.png)

![](../.gitbook/assets/image%20%2865%29.png)

```text
 public ArrayList<ArrayList<Integer>> taskAssignment(int k, ArrayList<Integer> tasks) {
		ArrayList<ArrayList<Integer>> pairedTasks =  new ArrayList<>();
		//task value and its corresponding index
		HashMap<Integer, ArrayList<Integer>> taskDurationToIndices =  getTaskDurationToIndices(tasks);
		
		ArrayList<Integer> sortedTasks = tasks;
    Collections.sort(sortedTasks);
		
		for(int idx = 0; idx < k; idx++){
			int task1Duration = sortedTasks.get(idx);
			ArrayList<Integer> indicesWithTask1Duration =  taskDurationToIndices.get(task1Duration); 
			int task1Idx =  indicesWithTask1Duration.remove(indicesWithTask1Duration.size() - 1);
			
			int task2SortedIndex = tasks.size() - 1 -idx;
			int task2Duration = sortedTasks.get(task2SortedIndex);
			ArrayList<Integer> indicesWithTask2Duration =  taskDurationToIndices.get(task2Duration); 
			int task2Idx =  indicesWithTask2Duration.remove(indicesWithTask2Duration.size() - 1);
			
			ArrayList<Integer> pairedTask =  new ArrayList<>();
			pairedTask.add(task1Idx);
			pairedTask.add(task2Idx);
			pairedTasks.add(pairedTask);
		}
    return pairedTasks;
  }
	
	
	public HashMap<Integer,ArrayList<Integer>> getTaskDurationToIndices(ArrayList<Integer> tasks){
		HashMap<Integer,ArrayList<Integer>> taskDurationToIndices = new HashMap<>();
		
		for(int idx =0; idx < tasks.size(); idx ++){
			int taskDuration =  tasks.get(idx);
			if(taskDurationToIndices.containsKey(taskDuration)){
				taskDurationToIndices.get(taskDuration).add(idx);
			}else{
				ArrayList<Integer> temp = new ArrayList<>();
				temp.add(idx);
				taskDurationToIndices.put(taskDuration,temp);
				
			}	
		}
		return taskDurationToIndices;
		
	}
```



### Valid Starting City:

![](../.gitbook/assets/image%20%2868%29.png)

![](../.gitbook/assets/image%20%2869%29.png)

* At city 4 we have a minimum negative amount of gas in the tank, that is mean we have to start from that index, if we start any city before city 4, we would not success, we must start from that city

```text
  public int validStartingCity(int[] distances, int[] fuel, int mpg) {
    int numberOfCities =  distances.length;
		int milesRemaining =0;
		
		int indexOfStartingCityCandidate = 0;
		int milesRemainingAtStartingCityCandidate = 0;
		
		for(int cityIdx = 1; cityIdx < numberOfCities; cityIdx ++){
			int distanceFromPreviousCity = distances[cityIdx -1];
			int fuelFromPreviousCity =  fuel[cityIdx - 1];
			milesRemaining  += fuelFromPreviousCity * mpg  - distanceFromPreviousCity;
			//update  indexOfStartingCityCandidate ,find last index that has negative fuel in the tank
			if(milesRemaining < milesRemainingAtStartingCityCandidate){
				milesRemainingAtStartingCityCandidate = milesRemaining;
				indexOfStartingCityCandidate = cityIdx;
				
			}
		
		}
    return indexOfStartingCityCandidate;
  }
```





## The Problem I struggle with:

* 1167. Minimum Cost to Connect Sticks
* Find Egyptian  Fraction:
* 253. Meeting Rooms II
* Help the Police Officers Catch the Thieves!
* Color the Graph:  完全没看懂





