# 18.Greedy

## Summary:

Greedy is an algorithmic paradigm where the solution is built piece by piece. The next piece that offers the most obvious and immediate benefit is chosen. The greedy approach always makes the choice that maximizes the profit and minimizes the cost at any given point. It means that a locally-optimal choice is made in the hope that it leads to a globally optimal solution

### Advantage:

* **Easy to devise**: It is easier to come up with a greedy approach for a single problem rather than computing solutions via other ways like binary search, dynamic programming
* **Compute the running time complexity:** Analyzing the run time for greedy algorithms is generally simpler than other techniques like traversals of trees, graph algorithms, or divide and conquer.

### Disadvantage:

* **Un-optimized solution**: One of the major disadvantages of the greedy approach is that initially, you might take a smaller step that leads to one big step that costs the maximum. Therefore, the final solution can never be optimized
* **Proof of correctness**: For greedy algorithms, it is harder to understand the correctness issues of a solution. Even with the correct algorithm, it is hard to prove why it is correct? While proving the correctness of a greedy algorithm, it requires a good deal of effort and patience. Moreover, the methods like proof of correctness via contradiction are used for this purpose

### 





## Easy:

### [322. Coin Change](https://leetcode.com/problems/coin-change/)

### This one need to use dp 

![](../.gitbook/assets/image%20%2851%29.png)

```text
//This only works for 1,5,10,25 cents case, does not apply to all the generic cases
public int coinChange(int[] coins, int amount) {
    Arrays.sort(coins);
    int index = coins.length -1;
    int count =0;
    for (int i = index; i >=0&& amount > 0; i--) // traverse through all available coins
    {
       while (amount >= coins[i]) // keep checking if the amount is greater than the max coin
       {
        amount -= coins[i]; // subtract the maximum coin selected from the total amount in every iteration
       count++;
       }

    }

        return   count ;
    }
```

## Medium:

### [1167. Minimum Cost to Connect Stick](https://leetcode.com/problems/minimum-cost-to-connect-sticks/)

```text
    public int connectSticks(int[] sticks) {
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        for (int s : sticks) {
            pq.offer(s);
        }
        int sum = 0;
        while (pq.size() > 1) {
            int two = pq.poll() + pq.poll();
            sum += two;
            pq.offer(two);
        }
        return sum;
    }
```

### Find Egyptian  Fraction:

Every positive fraction can be represented as sum of unique unit fractions. A fraction is unit fraction if numerator is 1 and denominator is a positive integer, for example 1/3 is a unit fraction. Such a representation is called Egyptian Fraction as it was used by ancient Egyptians. 

Following are few examples: 

`Egyptian Fraction Representation of 2/3 is 1/2 + 1/6`

`Egyptian Fraction Representation of 6/14 is 1/3 + 1/11 + 1/231`

`Egyptian Fraction Representation of 12/13 is 1/2 + 1/3 + 1/12 + 1/156`

**Solution:**

* **Time Complexity:**  O\(LOGN\)
* We can generate Egyptian fractions using the greedy algorithm. For a given number of the form n/d, where d &gt; n, first find the greatest possible unit fraction, and then perform recursion for the remaining part.
* For example, consider 6/14. We first find the ceiling of \lceil 14/6 \rceil⌈14/6⌉, i.e., 33, so the first unit fraction becomes 1/3. Now subtract 1/3 out of 6/14 and recur for \(\(6/14 – $1/3\), $ i.e.,4/42.
*  _the recursive calls keep on reducing the numerator till it reaches 1._ 

```text
 public static void printEgyptianFraction(int numerator, int denominator) 
    {
      //if either numerator or denominator is zero
      if (denominator == 0 || numerator == 0){
        return;
      }
      //numerator divides denominator -> fraction in 1/n form
      if (denominator % numerator == 0) {
        System.out.print("1/" + denominator / numerator);
        return;
      }
      //denominator can divide numerator -> number not a fraction 
      if (numerator % denominator == 0) {
        System.out.println(numerator / denominator);
        return;
      }
      //if numerator greater than denominator 
      if (numerator > denominator) {
        System.out.println(numerator / denominator + " , ");
        printEgyptianFraction(numerator % denominator, denominator);
        return;
      }
      //denominator  greater than numerator here
      int n = denominator / numerator + 1;
      System.out.print("1/" + n + " , ");
      //call function recursively for remaining part  
      printEgyptianFraction(numerator * n - denominator, denominator * n);
}
```





## Hard:





## The Problem I struggle with:

* 1167. Minimum Cost to Connect Sticks
* Find Egyptian  Fraction:





