# 18.Greedy

## Summary:

Greedy is an algorithmic paradigm where the solution is built piece by piece. The next piece that offers the most obvious and immediate benefit is chosen. The greedy approach always makes the choice that maximizes the profit and minimizes the cost at any given point. It means that a locally-optimal choice is made in the hope that it leads to a globally optimal solution

### Advantage:

* **Easy to devise**: It is easier to come up with a greedy approach for a single problem rather than computing solutions via other ways like binary search, dynamic programming
* **Compute the running time complexity:** Analyzing the run time for greedy algorithms is generally simpler than other techniques like traversals of trees, graph algorithms, or divide and conquer.

### Disadvantage:

* **Un-optimized solution**: One of the major disadvantages of the greedy approach is that initially, you might take a smaller step that leads to one big step that costs the maximum. Therefore, the final solution can never be optimized
* **Proof of correctness**: For greedy algorithms, it is harder to understand the correctness issues of a solution. Even with the correct algorithm, it is hard to prove why it is correct? While proving the correctness of a greedy algorithm, it requires a good deal of effort and patience. Moreover, the methods like proof of correctness via contradiction are used for this purpose

### 





## Easy:

### [322. Coin Change](https://leetcode.com/problems/coin-change/)

### This one need to use dp 

![](../.gitbook/assets/image%20%2853%29.png)

```text
//This only works for 1,5,10,25 cents case, does not apply to all the generic cases
public int coinChange(int[] coins, int amount) {
    Arrays.sort(coins);
    int index = coins.length -1;
    int count =0;
    for (int i = index; i >=0&& amount > 0; i--) // traverse through all available coins
    {
       while (amount >= coins[i]) // keep checking if the amount is greater than the max coin
       {
        amount -= coins[i]; // subtract the maximum coin selected from the total amount in every iteration
       count++;
       }

    }

        return   count ;
    }
```

### Find the Largest Number:

Given sum of digits and number of digits , give the largest number available

```text
 public static void findLargestNumber(int number_of_digits, int sum_of_digits) {
  int[] result = new int[number_of_digits];
  // If sum of digits is 0, then a number is possible only if number of digits is 1. 
  if (sum_of_digits == 0) {
   if (number_of_digits == 1) {
    System.out.print(0);
   } else {
    System.out.print("Noned");
   }
   return;
  }
  // sumOfDigits is greater than the maximum possible sum. 
  if (sum_of_digits > 9 * number_of_digits) {
   System.out.print("None");
   return;
  }
  // Fill from most significant digit to least significant digit! 
  for (int i = 0; i < number_of_digits; i++) {
   // Place 9 to make the number largest 
   if (sum_of_digits >= 9) {
    result[i] = 9;
    sum_of_digits -= 9;
   }
   // If remaining sum becomes less than 9, then fill the remaining sum 
   else {
    result[i] = sum_of_digits;
    sum_of_digits = 0;
   }
  }
  for (int i = 0; i < number_of_digits; i++) {
   System.out.print(result[i]);
  }
 }
```

* Fill in the digits one by one, from the leftmost to the rightmost digit

## Medium:

### [1167. Minimum Cost to Connect Stick](https://leetcode.com/problems/minimum-cost-to-connect-sticks/)

```text
    public int connectSticks(int[] sticks) {
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        for (int s : sticks) {
            pq.offer(s);
        }
        int sum = 0;
        while (pq.size() > 1) {
            int two = pq.poll() + pq.poll();
            sum += two;
            pq.offer(two);
        }
        return sum;
    }
```

### Find Egyptian  Fraction:

Every positive fraction can be represented as sum of unique unit fractions. A fraction is unit fraction if numerator is 1 and denominator is a positive integer, for example 1/3 is a unit fraction. Such a representation is called Egyptian Fraction as it was used by ancient Egyptians. 

Following are few examples: 

`Egyptian Fraction Representation of 2/3 is 1/2 + 1/6`

`Egyptian Fraction Representation of 6/14 is 1/3 + 1/11 + 1/231`

`Egyptian Fraction Representation of 12/13 is 1/2 + 1/3 + 1/12 + 1/156`

**Solution:**

* **Time Complexity:**  O\(LOGN\)
* We can generate Egyptian fractions using the greedy algorithm. For a given number of the form n/d, where d &gt; n, first find the greatest possible unit fraction, and then perform recursion for the remaining part.
* For example, consider 6/14. We first find the ceiling of \lceil 14/6 \rceil⌈14/6⌉, i.e., 33, so the first unit fraction becomes 1/3. Now subtract 1/3 out of 6/14 and recur for \(\(6/14 – $1/3\), $ i.e.,4/42.
*  _the recursive calls keep on reducing the numerator till it reaches 1._ 

```text
 public static void printEgyptianFraction(int numerator, int denominator) 
    {
      //if either numerator or denominator is zero
      if (denominator == 0 || numerator == 0){
        return;
      }
      //numerator divides denominator -> fraction in 1/n form
      if (denominator % numerator == 0) {
        System.out.print("1/" + denominator / numerator);
        return;
      }
      //denominator can divide numerator -> number not a fraction 
      if (numerator % denominator == 0) {
        System.out.println(numerator / denominator);
        return;
      }
      //if numerator greater than denominator 
      if (numerator > denominator) {
        System.out.println(numerator / denominator + " , ");
        printEgyptianFraction(numerator % denominator, denominator);
        return;
      }
      //denominator  greater than numerator here
      int n = denominator / numerator + 1;
      System.out.print("1/" + n + " , ");
      //call function recursively for remaining part  
      printEgyptianFraction(numerator * n - denominator, denominator * n);
}
```



### [253. Meeting Rooms II](https://leetcode.com/problems/meeting-rooms-ii/)

Implement a function that returns the minimum number of platforms that are required for the trains so that none of them wait.

![](../.gitbook/assets/image%20%2854%29.png)

![](../.gitbook/assets/image%20%2852%29.png)

* Time Complexity: O\(nlog n\)
* Create a min heap that sort by ending time
* Sort array in ascending order for starting time
* Then  calculate the current heap size to determine maximum room we need.

### Help the Police Officers Catch the Thieves!

The input is an array in which each element contains either a police officer \(P\) or a thief \(T\).

`Each police officer can catch only one thief, and a police officer cannot catch a thief who is more than k units away from him.`



![](../.gitbook/assets/image%20%2851%29.png)



* Brutal Force: check all the possible combinations of police and thief, and then return their maximum size set.
* Greedy Approach: ignoring the police officers and focusing on assigning police to thieves.
* We get the lowest index of policeman pp and thief t. We take the absolute value \( \|p-t\|\) and make an allotment if the difference of the indexes is less than k . Next, we increment to the next p and t. If the difference is not less than k, increment the minimum of p and t to the next pp or t found.

```text
public static int policeThief(char[] arr, int k) {
  int result = 0;
  ArrayList < Integer > thieves = new ArrayList < Integer > ();
  ArrayList < Integer > police = new ArrayList < Integer > ();
  int n = arr.length;
  //store indices in the respective vector
  for (int i = 0; i < n; i++) {
   if (arr[i] == 'P') {
    police.add(i);
   } 
   else if (arr[i] == 'T') {
    thieves.add(i);
   }
  }
  int trackThieves = 0, trackPolice = 0;
  while (trackThieves < thieves.size() && trackPolice < police.size()) {
   //thieves can be caught
   if (Math.abs(thieves.get(trackThieves) - police.get(trackPolice)) <= k) {
    result++;
    trackThieves++;
    trackPolice++;
   }
   //increment the minimum index 
   else if (thieves.get(trackThieves) < police.get(trackPolice)) {
    trackThieves++;
   } 
   else {
    trackPolice++;
   }
  }


  return result;
 }
```

## Hard:





## The Problem I struggle with:

* 1167. Minimum Cost to Connect Sticks
* Find Egyptian  Fraction:
* 253. Meeting Rooms II
* Help the Police Officers Catch the Thieves!





