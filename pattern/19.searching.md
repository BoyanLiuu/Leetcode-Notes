# 19.Searching





## Easy: 

### [Binary Search](https://leetcode.com/problems/binary-search/)

### Find Three Largest Numbers:

![](../.gitbook/assets/image%20%2866%29.png)

* Solution 1: Using top k technique with Time complexity O\(KLOGK\);
* Solution 2: Keep track current largest three elements, if current value bigger than index 1, we shift index 1 to left and shift index 0 to left;

```text
import java.util.*;

class Program {
  public static int[] findThreeLargestNumbers(int[] array) {
		int threeLargest [] =  {Integer.MIN_VALUE,Integer.MIN_VALUE,Integer.MIN_VALUE};
		for(int num: array){
			updateLargest(threeLargest,num);
		}
		return threeLargest;
  }
	
	
	public static void updateLargest(int[] threeLargest, int num){
		if(num > threeLargest[2]){
			shiftAndUpdate(threeLargest,num,2);
		}else if(num > threeLargest[1]){
				shiftAndUpdate(threeLargest,num,1);
		}else if(num > threeLargest[0]){
				shiftAndUpdate(threeLargest,num,0);
			
		}
		
	}
	public static void shiftAndUpdate(int[] array, int num, int idx){
		for(int i = 0; i <= idx; i++){
			if(i == idx){
				array[i] =num;
			}else{
				array[i] = array[i + 1];
			}
			
		}
		
	}
	
	
}

```





### 

## Medium:

### [240.Search In  Sorted Matrix:](https://leetcode.com/problems/search-a-2d-matrix-ii/)

* This is called Search Space Reduction
* We start  iterating row=0 and col = matrix\[0\].length -1  , top-right

```text
  public static int[] searchInSortedMatrix(int[][] matrix, int target) {
    int row = 0;
		int col =  matrix[0].length -1;
		
		while(row < matrix.length && col >=0){
			if(matrix[row][col] >target)
				col --;
			else if(matrix[row][col] <target)
				row++;
			else
				return new int[]{row,col};
			
		}
    return new int[] {-1, -1};
  }
```

### [33. Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/)

* use modified binary search

```text
  public int search(int[] nums, int target) {
    int start = 0, end = nums.length - 1;
    while (start <= end) {
      int mid = start + (end - start) / 2;
      if (nums[mid] == target) return mid;
      else if (nums[mid] >= nums[start]) {
        if (target >= nums[start] && target < nums[mid]) end = mid - 1;
        else start = mid + 1;
      }
      else {
        if (target <= nums[end] && target > nums[mid]) start = mid + 1;
        else end = mid - 1;
      }
    }
    return -1;
  }
```

### [34. Find First and Last Position of Element in Sorted Array](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

* 第一种方法： binary search 找到中点 然后左右分别扩张
* 第二种方法: 使用 2编 binary search 找出 start and end index， Time Complexity: O\(logN\)
  * findFirst --- &gt; 如果是 `if(nums[mid] >= target)   end = mid -1;`
  * findLast--- &gt; 如果是 `if(nums[mid] <= target)   start = mid +1;`

## Hard:

### [215. Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/)

## Problem that I struggle:

* \*\*\*\*[**Search In  Sorted Matrix:**](https://leetcode.com/problems/search-a-2d-matrix-ii/)\*\*\*\*
* \*\*\*\*[**33. Search in Rotated Sorted Array**](https://leetcode.com/problems/search-in-rotated-sorted-array/)\*\*\*\*

