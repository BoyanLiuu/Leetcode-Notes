# 19.Searching





## Easy: 

### [Binary Search](https://leetcode.com/problems/binary-search/)

### Find Three Largest Numbers:

![](../.gitbook/assets/image%20%2866%29.png)

* Solution 1: Using top k technique with Time complexity O\(KLOGK\);
* Solution 2: Keep track current largest three elements, if current value bigger than index 1, we shift index 1 to left and shift index 0 to left;

```text
import java.util.*;

class Program {
  public static int[] findThreeLargestNumbers(int[] array) {
		int threeLargest [] =  {Integer.MIN_VALUE,Integer.MIN_VALUE,Integer.MIN_VALUE};
		for(int num: array){
			updateLargest(threeLargest,num);
		}
		return threeLargest;
  }
	
	
	public static void updateLargest(int[] threeLargest, int num){
		if(num > threeLargest[2]){
			shiftAndUpdate(threeLargest,num,2);
		}else if(num > threeLargest[1]){
				shiftAndUpdate(threeLargest,num,1);
		}else if(num > threeLargest[0]){
				shiftAndUpdate(threeLargest,num,0);
			
		}
		
	}
	public static void shiftAndUpdate(int[] array, int num, int idx){
		for(int i = 0; i <= idx; i++){
			if(i == idx){
				array[i] =num;
			}else{
				array[i] = array[i + 1];
			}
			
		}
		
	}
	
	
}

```





### 

## Medium:

### [Search In  Sorted Matrix:](https://leetcode.com/problems/search-a-2d-matrix-ii/)

* This is called Search Space Reduction
* We start  iterating row=0 and col = matrix\[0\].length -1  , top-right

```text
  public static int[] searchInSortedMatrix(int[][] matrix, int target) {
    int row = 0;
		int col =  matrix[0].length -1;
		
		while(row < matrix.length && col >=0){
			if(matrix[row][col] >target)
				col --;
			else if(matrix[row][col] <target)
				row++;
			else
				return new int[]{row,col};
			
		}
    return new int[] {-1, -1};
  }
```



## Hard:

## Problem that I struggle:

* \*\*\*\*[**Search In  Sorted Matrix:**](https://leetcode.com/problems/search-a-2d-matrix-ii/)\*\*\*\*

