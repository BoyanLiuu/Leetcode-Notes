# 15. Recursion

## Summary:

* Recursion occurs when a function calls itself repeatedly until it reaches a specified stopping condition
* For a recursive function, you only need to define the base case and recursive case, so the code is simpler and shorter than an iterative code. Recursion is most useful for tasks that can be defined in terms of _**similar subtasks**_.
* Some of good cases to use recursion: 
  * Traverse tree, graphs
* Three ways to divide a problem into sub problems:
  * Bottom Up Approach:
    * We start with knowing how to solve the problem for a simple case, like a list with only one element, Then we figure out how to solve the problem for two elements.   The key here is to think about how you can build the solution for one case off of the previous case 
    * It is about dynamic programming

```text
class Solution {
    public int fib(int N) {
        if (N <= 1) {
            return N;
        }
        return memoize(N);
    }

    public int memoize(int N) {
      int[] cache = new int[N + 1];
      cache[1] = 1;

      for (int i = 2; i <= N; i++) {
          cache[i] = cache[i-1] + cache[i-2];
      }
      return cache[N];
    }
}
```

* Top-Down Approach:
  * It can be more complex since it is less concrete, Some times it is the best way to think about the problem In these problems, we think about how we can divide the problem for case N into subproblems. Be careful of overlap between the cases.
  * It is about memorization

```text
class Solution {
    private Integer[] cache = new Integer[31];

    public int fib(int N) {
        if (N <= 1) {
            return N;
        }
        cache[0] = 0;
        cache[1] = 1;
        return memoize(N);
    }

    public int memoize(int N) {
      if (cache[N] != null) {
          return cache[N];
      }
      cache[N] = memoize(N-1) + memoize(N-2);
      return memoize(N);
    }
}
```

* Half and Half Approach:
  * It is often effective to divide the data set in half. Such as binary search, we first figure out which half of the array contains the value. Then we recurse and search for it in that half



## Easy:

###  Find the Greatest Common Divisor   

![](../.gitbook/assets/image%20%2837%29.png)

```text
    public static int gcd(int num1, int num2) {

        // Base case
        if (num1 == num2) {
            return num1;
        }
        // Recursive case
        if (num1 > num2) {
            return gcd(num1-num2, num2);
        }
        else {
            return gcd(num1, num2-num1);
        }
    }
```

![](../.gitbook/assets/image%20%2838%29.png)



### Search for a Value in a Linked List:

* 超简单的题目

```text
    public static boolean search(Node head, int num) { 
      // Base case
      if (head == null) {
        return false;
      }

      // Recursive case
      else {
        if (head.value == num) {
          return true;
        }
        else {
          return search(head.next, num);
        }
      }
    } 
```

### [509. Fibonacci Number](https://leetcode.com/problems/fibonacci-number/)

* The best is O\(N\) and O\(1\) space



## 

## 

## Medium:

### Checks if a number is prime or not



```text
    public static boolean isPrime(int num, int i) {

        // First base case
        if (num < 2) {
            return false;
        }
        // Second base case
        else if (i == 1) {
            return true;
        }
        // Third base case
        else if (num%i == 0) {
            return false;
        }
        // Recursive case
        else {
            return isPrime(num, i-1);
        }
    }
```

###  Convert Decimal Number to Binary Number:

![](../.gitbook/assets/image%20%2839%29.png)

* We keep dividing the number by 2 until it reaches 1 and records the remainder at each step

```text
   public static int decimalToBinary(int decimalNum) {
        if (decimalNum == 0) {
            return 0;
        }
        else {
            return (decimalNum%2 + 10*decimalToBinary(decimalNum/2));
        }
    }
```

![](../.gitbook/assets/image%20%2840%29.png)



### [125. Valid Palindrome](https://leetcode.com/problems/valid-palindrome/)

```text
    public static boolean isPalindrome(String text) {
        if (text.length() == 0) {
            return false;
        }
        else if (text.length() == 1) {
            return true;
        }
        else {
            if (text.charAt(0) == text.charAt(text.length()-1)) {
                return isPalindrome(text.substring(1, text.length()-1));
            }
        }
        return false;
    }
```

### Sort an array:

```text
  public static void sortArray(int[] array, int n) {
      if (n==1) {
          return;
      }
      for (int i = 0; i < n-1; i++) {
          if (array[i] > array[i+1]) {
              int temp = array[i];
              array[i] = array[i+1];
              array[i+1] = temp;
          }
      }
      sortArray(array, n-1);
  }
```

### [46. Permutations](https://leetcode.com/problems/permutations/)

### [78. Subsets](https://leetcode.com/problems/subsets/)

### [17. Letter Combinations of a Phone Number](https://leetcode.com/problems/letter-combinations-of-a-phone-number/)

### Staircase traversal:

### [236. Lowest Common Ancestor of a Binary Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/)

### [22. Generate Parentheses](https://leetcode.com/problems/generate-parentheses/)

## Hard:

### Ambiguous Measurement:

### Number of Binary Tree Topologies:

### [37. Sudoku Solver](https://leetcode.com/problems/sudoku-solver/)

### [97. Interleaving String](https://leetcode.com/problems/interleaving-string/)





## Problem I struggle with:

* From Decimal to Binary
* 125. Valid Palindrome
* Sort an array:
* \*\*\*\*[**509. Fibonacci Number**](https://leetcode.com/problems/fibonacci-number/)\*\*\*\*

