# 15. Recursion

## Summary:

* Recursion occurs when a function calls itself repeatedly until it reaches a specified stopping condition
* For a recursive function, you only need to define the base case and recursive case, so the code is simpler and shorter than an iterative code. Recursion is most useful for tasks that can be defined in terms of _**similar subtasks**_.
* Some of good cases to use recursion: 
  * Traverse tree, graphs
* Three ways to divide a problem into sub problems:
  * Bottom Up Approach:
    * We start with knowing how to solve the problem for a simple case, like a list with only one element, Then we figure out how to solve the problem for two elements.   The key here is to think about how you can build the solution for one case off of the previous case 
    * It is about dynamic programming

```text
class Solution {
    public int fib(int N) {
        if (N <= 1) {
            return N;
        }
        return memoize(N);
    }

    public int memoize(int N) {
      int[] cache = new int[N + 1];
      cache[1] = 1;

      for (int i = 2; i <= N; i++) {
          cache[i] = cache[i-1] + cache[i-2];
      }
      return cache[N];
    }
}
```

* Top-Down Approach:
  * It can be more complex since it is less concrete, Some times it is the best way to think about the problem In these problems, we think about how we can divide the problem for case N into subproblems. Be careful of overlap between the cases.
  * It is about memorization

```text
class Solution {
    private Integer[] cache = new Integer[31];

    public int fib(int N) {
        if (N <= 1) {
            return N;
        }
        cache[0] = 0;
        cache[1] = 1;
        return memoize(N);
    }

    public int memoize(int N) {
      if (cache[N] != null) {
          return cache[N];
      }
      cache[N] = memoize(N-1) + memoize(N-2);
      return memoize(N);
    }
}
```

* Half and Half Approach:
  * It is often effective to divide the data set in half. Such as binary search, we first figure out which half of the array contains the value. Then we recurse and search for it in that half



## Easy:

###  Find the Greatest Common Divisor   

![](../.gitbook/assets/image%20%2837%29.png)

```text
    public static int gcd(int num1, int num2) {

        // Base case
        if (num1 == num2) {
            return num1;
        }
        // Recursive case
        if (num1 > num2) {
            return gcd(num1-num2, num2);
        }
        else {
            return gcd(num1, num2-num1);
        }
    }
```

![](../.gitbook/assets/image%20%2838%29.png)



### Search for a Value in a Linked List:

* 超简单的题目

```text
    public static boolean search(Node head, int num) { 
      // Base case
      if (head == null) {
        return false;
      }

      // Recursive case
      else {
        if (head.value == num) {
          return true;
        }
        else {
          return search(head.next, num);
        }
      }
    } 
```

### [509. Fibonacci Number](https://leetcode.com/problems/fibonacci-number/)

* The best is O\(N\) and O\(1\) space



## 

## 

## Medium:

### Checks if a number is prime or not



```text
    public static boolean isPrime(int num, int i) {

        // First base case
        if (num < 2) {
            return false;
        }
        // Second base case
        else if (i == 1) {
            return true;
        }
        // Third base case
        else if (num%i == 0) {
            return false;
        }
        // Recursive case
        else {
            return isPrime(num, i-1);
        }
    }
```

###  Convert Decimal Number to Binary Number:

![](../.gitbook/assets/image%20%2839%29.png)

* We keep dividing the number by 2 until it reaches 1 and records the remainder at each step

```text
   public static int decimalToBinary(int decimalNum) {
        if (decimalNum == 0) {
            return 0;
        }
        else {
            return (decimalNum%2 + 10*decimalToBinary(decimalNum/2));
        }
    }
```

![](../.gitbook/assets/image%20%2840%29.png)



### [125. Valid Palindrome](https://leetcode.com/problems/valid-palindrome/)

```text
    public static boolean isPalindrome(String text) {
        if (text.length() == 0) {
            return false;
        }
        else if (text.length() == 1) {
            return true;
        }
        else {
            if (text.charAt(0) == text.charAt(text.length()-1)) {
                return isPalindrome(text.substring(1, text.length()-1));
            }
        }
        return false;
    }
```

### Sort an array:

```text
  public static void sortArray(int[] array, int n) {
      if (n==1) {
          return;
      }
      for (int i = 0; i < n-1; i++) {
          if (array[i] > array[i+1]) {
              int temp = array[i];
              array[i] = array[i+1];
              array[i+1] = temp;
          }
      }
      sortArray(array, n-1);
  }
```

### Product Sum:

**Question:**

![](../.gitbook/assets/image%20%2841%29.png)

**Answer:** 

* 做出来了
* O（N） time complexity, Where n is the total number of elements in the array
* O\(d\) space complexity, and d is the greatest depth of special arrays in the array

```text
  public static int productSum(List<Object> array) {

    return helper(array,1);
  }
	
	private static int helper(List<Object> array,int level){
				int sum = 0;
    for(Object obj : array){
			if(obj instanceof ArrayList){
				ArrayList<Object> ls =  (ArrayList<Object>) obj;
				
				 sum+=  helper(ls,level + 1 );
				
			}else{
				sum+= (int)obj;
				
			}
			
		}
		return sum* level;
	}
```

### [46. Permutations](https://leetcode.com/problems/permutations/)

* Iterative way: Add current index element to each location of current permutation

```text
class Solution {
    public List<List<Integer>> permute(int[] nums) {
            List<List<Integer>> result = new ArrayList<>();
    Queue<List<Integer>> permutations = new LinkedList<>();
    permutations.add(new ArrayList<>());
        
    for (int currentNumber : nums) {
      // we will take all existing permutations and add the current number to create new permutations
      int n = permutations.size();
      for (int i = 0; i < n; i++) {
        List<Integer> oldPermutation = permutations.poll();
        // create a new permutation by adding the current number at every position
        for (int j = 0; j <= oldPermutation.size(); j++) {
          List<Integer> newPermutation = new ArrayList<Integer>(oldPermutation);
        // add index at each location
          newPermutation.add(j, currentNumber);
          if (newPermutation.size() == nums.length)
            result.add(newPermutation);
          else
            permutations.add(newPermutation);
        }
      }
    }
    return result;
    }
}
```

* Recursive: Remove current index element from list

```text
class Solution {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> res =new ArrayList<>();
        ArrayList<Integer> array =  new ArrayList<Integer>();
        for (int i : nums)
            {
                array.add(i);
            }
        helper(res,array,new ArrayList<>());
        return res;
    }
    
    private  void helper(List<List<Integer>> permutation,List<Integer> array,List<Integer>currentPermutation){
		
		//base case
		if(array.size() == 0 && currentPermutation.size() >0){
			permutation.add(currentPermutation);
		}else{
			
			for(int i = 0; i <array.size();i++){
				List<Integer> newArray = new ArrayList<Integer>(array);
				newArray.remove(i);
				List<Integer> newPermutation =  new ArrayList<Integer>(currentPermutation);
				newPermutation.add(array.get(i));
			  helper(permutation,newArray,newPermutation);
			}
		}
		
	}
}
```

### [78. Subsets](https://leetcode.com/problems/subsets/)

* Recursion 思路跟 46 题目很像

### [17. Letter Combinations of a Phone Number](https://leetcode.com/problems/letter-combinations-of-a-phone-number/)

* Time Complexity:
  * O\(4^N\*N\)
    * 4^N number of recursive call at most to our recursion function ![](../.gitbook/assets/image%20%2844%29.png) 
    * N is for create a new string, it take O\(N\) for

### [236. Lowest Common Ancestor of a Binary Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/)

### [22. Generate Parentheses](https://leetcode.com/problems/generate-parentheses/)

### Staircase traversal:

## Hard:

### Ambiguous Measurement:

### Number of Binary Tree Topologies:

### [37. Sudoku Solver](https://leetcode.com/problems/sudoku-solver/)

### [97. Interleaving String](https://leetcode.com/problems/interleaving-string/)

### 





## Problem I struggle with:

* From Decimal to Binary
* 125. Valid Palindrome
* Sort an array:
* \*\*\*\*[**509. Fibonacci Number**](https://leetcode.com/problems/fibonacci-number/)\*\*\*\*
* \*\*\*\*[**46. Permutations**](https://leetcode.com/problems/permutations/)\*\*\*\*

